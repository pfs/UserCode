// Class: ReadBDT_VBF0HighMJJ
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT_VBF0HighMJJ
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.10/09       [395785]
Creator        : ajafari
Date           : Fri Nov 16 19:56:03 2018
Host           : Linux cmsbuild49.cern.ch 2.6.32-696.10.2.el6.x86_64 #1 SMP Thu Sep 14 16:35:02 CEST 2017 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /afs/cern.ch/work/a/ajafari/Vjj/CMSSW_9_4_2/src/TopLJets2015/TopAnalysis/macro
Training events: 29060
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
CreateMVAPdfs: "True" [Create PDFs for classifier outputs (signal and background)]
nCuts: "0" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
SeparationType: "giniindex" [Separation criterion for node splitting]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
NTrees: "50" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "6.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "4" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 14
D                             D                             D                             D                                                               'F'    [3.70234821533e-13,0.228659808636]
C                             C                             C                             C                                                               'F'    [0.0107004772872,0.72715306282]
circularity                   circularity                   circularity                   circularity                                                     'F'    [0.00168784300331,0.897996246815]
balance                       balance                       balance                       balance                                                         'F'    [0.323038250208,600.413208008]
jjpt                          jjpt                          jjpt                          jjpt                                                            'F'    [1.5927734375,702.789306641]
ystar                         ystar                         ystar                         ystar                                                           'F'    [-3.5614168644,3.36709594727]
dphijj                        dphijj                        dphijj                        dphijj                                                          'F'    [-3.14146089554,3.14152264595]
dphivj0                       dphivj0                       dphivj0                       dphivj0                                                         'F'    [0.00175261497498,3.14147353172]
j_pt[1]                       j_pt_1_                       j_pt[1]                       SubleadJetPt                                                    'F'    [0,743.551818848]
j_c2_00[0]                    j_c2_00_0_                    j_c2_00[0]                    jet_c2_001                                                      'F'    [-1,0.651101589203]
j_c2_00[1]                    j_c2_00_1_                    j_c2_00[1]                    jet_c2_002                                                      'F'    [-1,0.641687572002]
j_gawidth[0]                  j_gawidth_0_                  j_gawidth[0]                  jet_gawidth1                                                    'F'    [0.00705154193565,0.627484381199]
mjj                           mjj                           mjj                           mjj                                                             'F'    [1000.02545166,9690.50488281]
j_qg[1]                       j_qg_1_                       j_qg[1]                       subleadjet_qg                                                   'F'    [-1,1]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDT_VBF0HighMJJNode
   
#ifndef BDT_VBF0HighMJJNode__def
#define BDT_VBF0HighMJJNode__def
   
class BDT_VBF0HighMJJNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDT_VBF0HighMJJNode ( BDT_VBF0HighMJJNode* left,BDT_VBF0HighMJJNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDT_VBF0HighMJJNode();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDT_VBF0HighMJJNode* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDT_VBF0HighMJJNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDT_VBF0HighMJJNode*   fLeft;     // pointer to the left daughter node
   BDT_VBF0HighMJJNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDT_VBF0HighMJJNode::~BDT_VBF0HighMJJNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDT_VBF0HighMJJNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDT_VBF0HighMJJNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT_VBF0HighMJJ : public IClassifierReader {

 public:

   // constructor
   ReadBDT_VBF0HighMJJ( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT_VBF0HighMJJ" ),
        fNvars( 14 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "D", "C", "circularity", "balance", "jjpt", "ystar", "dphijj", "dphivj0", "j_pt[1]", "j_c2_00[0]", "j_c2_00[1]", "j_gawidth[0]", "mjj", "j_qg[1]" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;
      fVmin[10] = 0;
      fVmax[10] = 0;
      fVmin[11] = 0;
      fVmax[11] = 0;
      fVmin[12] = 0;
      fVmax[12] = 0;
      fVmin[13] = 0;
      fVmax[13] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';
      fType[10] = 'F';
      fType[11] = 'F';
      fType[12] = 'F';
      fType[13] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT_VBF0HighMJJ() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[14];
   double fVmax[14];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[14];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDT_VBF0HighMJJNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT_VBF0HighMJJ::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDT_VBF0HighMJJNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDT_VBF0HighMJJNode*)current->GetRight();
         else current=(BDT_VBF0HighMJJNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT_VBF0HighMJJ::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.43324197250447);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 83.8899, 1, 1, 0.776533,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.659036,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438725,-99) , 
3, 41.0007, 1, 0, 0.534413,-99) , 
12, 1734.24, 0, 0, 0.591777,-99) , 
NN(
0, 
0, 
-1, 2.79788, 1, -1, 0.249436,-99) , 
8, 53.6954, 0, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.395466);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.669801,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452788,-99) , 
5, 0.808175, 1, 0, 0.605575,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.264137,-99) , 
5, -1.68129, 0, 0, 0.573574,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.257849,-99) , 
8, 44.1717, 0, 0, 0.522734,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.328709);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1144.59, 0, 1, 0.62923,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554332,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.304904,-99) , 
8, 64.2347, 0, 0, 0.426524,-99) , 
7, 2.90366, 1, 0, 0.569509,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520185,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.354743,-99) , 
12, 1251.38, 0, 0, 0.443128,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.259534,-99) , 
13, 0.397225, 0, 0, 0.362652,-99) , 
5, -0.991381, 0, 0, 0.518181,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.283602);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.602031,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417276,-99) , 
9, 0.572362, 1, 0, 0.565603,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.388016,-99) , 
5, -1.34752, 0, 0, 0.537335,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.608275,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511415,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.286649,-99) , 
6, -2.23959, 1, 0, 0.363214,-99) , 
6, 2.71693, 0, 0, 0.405612,-99) , 
7, 2.79793, 1, 0, 0.48307,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.189515);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 15.2431, 1, 1, 0.546575,-99) , 
NN(
0, 
0, 
-1, 0.374178, 0, -1, 0.413947,-99) , 
10, 0.538463, 1, 0, 0.492742,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.298214,-99) , 
5, 1.57393, 1, 0, 0.470778,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.256449);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.623908,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.428693,-99) , 
7, 2.99665, 1, 0, 0.58359,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.392046,-99) , 
3, 83.9377, 1, 0, 0.540319,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.616704,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511718,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.373355,-99) , 
11, 0.111956, 1, 0, 0.405801,-99) , 
3, 13.5151, 1, 0, 0.422759,-99) , 
12, 1426.86, 0, 0, 0.468278,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.184511);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.752848,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552804,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459798,-99) , 
3, 56.4419, 1, 0, 0.516463,-99) , 
12, 2472.74, 0, 0, 0.528674,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553848,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.425065,-99) , 
5, -0.506063, 0, 0, 0.506319,-99) , 
NN(
0, 
0, 
-1, -2.2362, 1, -1, 0.388924,-99) , 
6, 2.1784, 0, 0, 0.431936,-99) , 
2, 0.393271, 0, 0, 0.478718,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.115558);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.632099,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507463,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.402348,-99) , 
13, 0.198631, 0, 0, 0.486446,-99) , 
12, 2134.27, 0, 0, 0.500972,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.325058,-99) , 
5, 1.71419, 1, 0, 0.485925,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.129459);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.598037,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506665,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.415882,-99) , 
5, -0.88663, 0, 0, 0.476046,-99) , 
NN(
0, 
0, 
-1, 2.59991, 1, -1, 0.382281,-99) , 
5, 1.21799, 1, 0, 0.458073,-99) , 
12, 2134.27, 0, 0, 0.471406,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.165274);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.589258,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542005,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.418802,-99) , 
12, 1148.82, 0, 0, 0.503421,-99) , 
NN(
0, 
0, 
-1, 1.33182, 0, -1, 0.425571,-99) , 
6, -1.68443, 1, 0, 0.455602,-99) , 
3, 13.5153, 1, 0, 0.466103,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.155813);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.694606,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551589,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45819,-99) , 
1, 0.146133, 0, 0, 0.5129,-99) , 
12, 2134.27, 0, 0, 0.528278,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.556502,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4712,-99) , 
2, 0.659047, 0, 0, 0.484016,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.324763,-99) , 
6, -1.30923, 1, 0, 0.444756,-99) , 
6, 1.33182, 0, 0, 0.480824,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.154876);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.60484,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.431182,-99) , 
4, 176.427, 1, 0, 0.570291,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424446,-99) , 
13, 0.166402, 0, 0, 0.540605,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.627723,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479649,-99) , 
5, -0.157354, 0, 0, 0.506874,-99) , 
NN(
0, 
0, 
-1, 0.000835651, 0, -1, 0.433028,-99) , 
5, 0.318957, 1, 0, 0.474355,-99) , 
12, 1551.3, 0, 0, 0.494028,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.111065);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.247579, 0, 1, 0.545811,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519484,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417381,-99) , 
11, 0.263857, 1, 0, 0.486733,-99) , 
9, 0.535841, 1, 0, 0.522787,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.432027,-99) , 
7, 3.05775, 1, 0, 0.512788,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.0528723);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.635023,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.608279,-99) , 
NN(
0, 
0, 
-1, 3.02654, 1, -1, 0.486576,-99) , 
2, 0.0859552, 1, 0, 0.492572,-99) , 
3, 8.59565, 1, 0, 0.497346,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.0784499);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 25.7014, 1, 1, 0.536927,-99) , 
NN(
0, 
0, 
-1, 169.456, 1, -1, 0.483853,-99) , 
9, 0.535833, 1, 0, 0.516085,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424155,-99) , 
5, 1.71419, 1, 0, 0.508519,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.104954);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.594438,-99) , 
NN(
NN(
0, 
0, 
-1, 2134.27, 0, 1, 0.532613,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519776,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.418483,-99) , 
6, -1.68443, 1, 0, 0.480614,-99) , 
6, 1.92372, 0, 0, 0.499456,-99) , 
10, 0.406797, 1, 0, 0.506341,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.0860156);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.58561,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526383,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470754,-99) , 
0, 0.00309502, 0, 0, 0.49151,-99) , 
12, 2315.18, 0, 0, 0.497531,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.392132,-99) , 
3, 139.708, 1, 0, 0.492087,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.0586681);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.613264,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506752,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.425282,-99) , 
7, 3.02654, 1, 0, 0.497631,-99) , 
2, 0.088199, 1, 0, 0.503464,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.408524,-99) , 
8, 208.923, 1, 0, 0.496782,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.085341);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.607773,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.581318,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.558724,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47163,-99) , 
10, 0.406797, 1, 0, 0.477919,-99) , 
2, 0.0859552, 1, 0, 0.482971,-99) , 
3, 8.59565, 1, 0, 0.487074,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.0994142);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.633917,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487201,-99) , 
8, 73.9012, 1, 0, 0.553251,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.563417,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477154,-99) , 
6, -2.54936, 1, 0, 0.493331,-99) , 
1, 0.111972, 1, 0, 0.507473,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.427643,-99) , 
4, 47.2667, 0, 0, 0.502251,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.123076);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.642356,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.568479,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477858,-99) , 
3, 47.4878, 0, 0, 0.522969,-99) , 
8, 53.5474, 1, 0, 0.54377,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.557177,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484897,-99) , 
11, 0.184271, 0, 0, 0.513833,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.421198,-99) , 
6, -1.30923, 1, 0, 0.493307,-99) , 
6, 1.21148, 0, 0, 0.515661,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0872139);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.644298,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495434,-99) , 
8, 77.6376, 1, 0, 0.57268,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525249,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456379,-99) , 
5, -1.5913, 0, 0, 0.517445,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440776,-99) , 
4, 47.3673, 0, 0, 0.511592,-99) , 
3, 17.7362, 1, 0, 0.519998,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0632567);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -0.373913, 0, 1, 0.572431,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510706,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464194,-99) , 
9, 0.433786, 0, 0, 0.502773,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417871,-99) , 
3, 139.708, 1, 0, 0.497691,-99) , 
3, 17.7362, 1, 0, 0.507941,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0603176);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.630441,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493482,-99) , 
6, -0.373913, 0, 0, 0.556883,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505173,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44515,-99) , 
2, 0.650483, 1, 0, 0.495083,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.427736,-99) , 
5, 1.6387, 1, 0, 0.48884,-99) , 
3, 17.7362, 1, 0, 0.498144,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.101185);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.620212,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487316,-99) , 
5, 0.372373, 1, 0, 0.558258,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545055,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474303,-99) , 
11, 0.192141, 0, 0, 0.504492,-99) , 
NN(
0, 
0, 
-1, 0.239768, 1, -1, 0.458855,-99) , 
2, 0.393271, 0, 0, 0.481146,-99) , 
3, 17.7362, 1, 0, 0.491666,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0682628);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1399.51, 0, 1, 0.571341,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510987,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450176,-99) , 
12, 1080.37, 0, 0, 0.500723,-99) , 
3, 17.7362, 1, 0, 0.510308,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.425008,-99) , 
9, 0.602087, 1, 0, 0.504238,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0887996);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1509.84, 0, 1, 0.542645,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533217,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478884,-99) , 
6, 1.92349, 0, 0, 0.4992,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531501,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.428965,-99) , 
5, -0.725545, 1, 0, 0.457712,-99) , 
11, 0.241558, 1, 0, 0.486629,-99) , 
3, 17.7362, 1, 0, 0.494225,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0778915);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.574696,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484604,-99) , 
4, 90.4199, 0, 0, 0.534379,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510179,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458846,-99) , 
6, 1.21148, 0, 0, 0.489937,-99) , 
6, -2.29326, 1, 0, 0.502316,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.431369,-99) , 
8, 208.266, 1, 0, 0.497159,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0844946);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.617542,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53707,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476023,-99) , 
3, 38.7641, 0, 0, 0.509465,-99) , 
11, 0.0698913, 1, 0, 0.518682,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.576903,-99) , 
NN(
0, 
0, 
-1, 2.20068, 0, -1, 0.470482,-99) , 
12, 2298.11, 0, 0, 0.477305,-99) , 
6, -1.30923, 1, 0, 0.495298,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0462429);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.592254,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507912,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424382,-99) , 
10, 0.43946, 0, 0, 0.502878,-99) , 
10, 0.40556, 1, 0, 0.507993,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.426659,-99) , 
13, 0.997427, 1, 0, 0.504163,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.10605);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.607337,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477999,-99) , 
5, 0.23103, 1, 0, 0.543488,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.38531,-99) , 
13, 0.978322, 1, 0, 0.520355,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548572,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477993,-99) , 
6, -2.56627, 1, 0, 0.492212,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.400516,-99) , 
1, 0.0698153, 0, 0, 0.485032,-99) , 
3, 27.8309, 1, 0, 0.494944,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.103837);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.619249,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.573345,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480584,-99) , 
3, 63.7307, 0, 0, 0.509417,-99) , 
8, 66.924, 1, 0, 0.531358,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554569,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4612,-99) , 
0, 0.00633512, 1, 0, 0.532897,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545857,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469397,-99) , 
1, 0.249837, 0, 0, 0.479664,-99) , 
11, 0.121224, 1, 0, 0.496578,-99) , 
2, 0.504319, 0, 0, 0.508005,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.111381);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.73153, 1, 1, 0.555608,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524348,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444789,-99) , 
4, 83.1028, 0, 0, 0.503158,-99) , 
13, 0.640749, 0, 0, 0.524521,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540654,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437418,-99) , 
5, -0.749833, 0, 0, 0.50947,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.398358,-99) , 
11, 0.220932, 1, 0, 0.482803,-99) , 
8, 140.084, 1, 0, 0.514703,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0408898);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 195.515, 0, 1, 0.510306,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461838,-99) , 
5, -1.45306, 0, 0, 0.503485,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.432046,-99) , 
3, 139.708, 1, 0, 0.499756,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0509818);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.563617,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492355,-99) , 
1, 0.101626, 1, 0, 0.501858,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.436953,-99) , 
1, 0.0658111, 0, 0, 0.497537,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44547,-99) , 
5, 1.72328, 1, 0, 0.493326,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0975419);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.603591,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514682,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44465,-99) , 
12, 1069.86, 0, 0, 0.503105,-99) , 
8, 55.0568, 1, 0, 0.517432,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.593228,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475158,-99) , 
5, -0.394204, 0, 0, 0.508324,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537523,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442517,-99) , 
12, 1627.15, 0, 0, 0.46509,-99) , 
5, 0.347452, 1, 0, 0.489018,-99) , 
2, 0.388203, 0, 0, 0.503174,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0878638);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 76.6506, 1, 1, 0.564706,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538783,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483993,-99) , 
6, 2.45961, 0, 0, 0.497854,-99) , 
7, 2.68339, 1, 0, 0.512299,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550004,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467767,-99) , 
0, 0.00208177, 1, 0, 0.491937,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.401635,-99) , 
7, 2.40261, 1, 0, 0.478306,-99) , 
7, 2.47934, 0, 0, 0.500321,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0548813);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.591611,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479756,-99) , 
5, 0.246928, 1, 0, 0.535465,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.559403,-99) , 
NN(
0, 
0, 
-1, 0.59586, 1, -1, 0.491437,-99) , 
4, 62.0668, 1, 0, 0.499354,-99) , 
8, 52.7026, 1, 0, 0.506669,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0807876);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.588809,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454827,-99) , 
8, 103.6, 1, 0, 0.55513,-99) , 
NN(
0, 
0, 
-1, 0.571296, 0, 1, 0.510412,-99) , 
11, 0.24793, 0, 0, 0.523101,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.573729,-99) , 
NN(
0, 
0, 
-1, 0.514764, 0, -1, 0.46104,-99) , 
9, 0.460553, 1, 0, 0.48814,-99) , 
3, 77.1055, 1, 0, 0.515104,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0902957);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.630732,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482692,-99) , 
9, 0.537486, 1, 0, 0.564778,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456853,-99) , 
8, 97.7461, 1, 0, 0.526666,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528425,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487879,-99) , 
9, 0.518783, 0, 0, 0.505684,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.426343,-99) , 
5, 1.49335, 1, 0, 0.495549,-99) , 
11, 0.247931, 0, 0, 0.504168,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0778704);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.585711,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499367,-99) , 
8, 96.8978, 1, 0, 0.554454,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44689,-99) , 
12, 1933.48, 1, 0, 0.533255,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51691,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464208,-99) , 
5, -1.4559, 0, 0, 0.50846,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448567,-99) , 
5, 1.49335, 1, 0, 0.500842,-99) , 
11, 0.247931, 0, 0, 0.509797,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0814701);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.617849,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543273,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462637,-99) , 
7, 2.4618, 0, 0, 0.51488,-99) , 
11, 0.275249, 1, 0, 0.532925,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540793,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515735,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471559,-99) , 
6, -2.28534, 1, 0, 0.486047,-99) , 
4, 195.493, 0, 0, 0.491766,-99) , 
11, 0.247931, 0, 0, 0.503117,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0587063);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 111.282, 1, 1, 0.547127,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513079,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46638,-99) , 
9, 0.537548, 1, 0, 0.500653,-99) , 
9, 0.579661, 0, 0, 0.507588,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454317,-99) , 
8, 208.923, 1, 0, 0.503787,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0792028);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.610614,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.564794,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458526,-99) , 
5, 0.241042, 0, 0, 0.500848,-99) , 
0, 0.0128149, 1, 0, 0.525584,-99) , 
NN(
NN(
0, 
0, 
-1, 2010.84, 0, 1, 0.521399,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515472,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467708,-99) , 
3, 24.9436, 1, 0, 0.480156,-99) , 
6, 2.34166, 0, 0, 0.491252,-99) , 
0, 0.00926156, 0, 0, 0.497377,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0849401);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 96.5535, 1, 1, 0.542283,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456522,-99) , 
11, 0.120033, 0, 0, 0.517573,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533892,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471554,-99) , 
8, 88.9745, 0, 0, 0.505575,-99) , 
NN(
0, 
0, 
-1, -0.955807, 0, -1, 0.467745,-99) , 
3, 38.764, 0, 0, 0.489151,-99) , 
2, 0.504319, 0, 0, 0.498457,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0824625);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55495,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496573,-99) , 
3, 32.3269, 1, 0, 0.517223,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523923,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.425858,-99) , 
1, 0.158118, 1, 0, 0.470689,-99) , 
10, 0.579959, 1, 0, 0.509879,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587473,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473566,-99) , 
3, 60.592, 1, 0, 0.510427,-99) , 
NN(
0, 
0, 
-1, 2.68234, 1, -1, 0.421458,-99) , 
3, 40.2199, 0, 0, 0.472332,-99) , 
13, 0.93497, 1, 0, 0.500982,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0925908);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1251.64, 0, 1, 0.530335,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530909,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.39595,-99) , 
13, 0.777323, 1, 0, 0.476522,-99) , 
12, 1714.99, 1, 0, 0.518735,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.562464,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508078,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4229,-99) , 
8, 92.0196, 1, 0, 0.473867,-99) , 
12, 1693.01, 0, 0, 0.49164,-99) , 
3, 35.4645, 0, 0, 0.508175,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0524695);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54052,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510487,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478415,-99) , 
5, 0.213348, 1, 0, 0.495489,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.439102,-99) , 
10, 0.452813, 0, 0, 0.4896,-99) , 
10, 0.406797, 1, 0, 0.493266,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0739115);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.617147,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450897,-99) , 
4, 106.899, 0, 0, 0.536144,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513378,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476051,-99) , 
4, 106.422, 1, 0, 0.491247,-99) , 
10, 0.558432, 0, 0, 0.497844,-99) , 
NN(
0, 
0, 
-1, 1245.64, 0, -1, 0.457395,-99) , 
10, 0.579959, 1, 0, 0.492882,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0907892);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.58128,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.560391,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4873,-99) , 
10, 0.557988, 0, 0, 0.503747,-99) , 
9, 0.406042, 1, 0, 0.511774,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550743,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45504,-99) , 
13, 0.956803, 1, 0, 0.517783,-99) , 
NN(
0, 
0, 
-1, 0.139054, 0, -1, 0.452432,-99) , 
8, 94.7667, 0, 0, 0.48019,-99) , 
4, 108.74, 0, 0, 0.497657,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT_VBF0HighMJJ::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT_VBF0HighMJJ::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
